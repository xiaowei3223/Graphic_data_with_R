
#=========================================================================================
#创建数据框
#=========================================================================================
#把向量放在data.frame()里面

#从最简单的向量开始
g <- c("A", "B", "C")
x <- 1:3
dat <- data.frame(g,x)
dat

#=========================================================================================
#从数据框中提取信息
#=========================================================================================
#使用str()函数
str(ToothGrowth)

tg <- ToothGrowth
tg$supp <- as.character(tg$supp)
str(tg)

#直接输出列
#原始数据框（因子）
ToothGrowth$supp
#新数据
tg$supp

#=========================================================================================
#向数据框中删除一列
#=========================================================================================
data$newcol <- NA
dat6a$newcol <- vec

#=========================================================================================
#重命名数据框的列名
#=========================================================================================
names(dat) <- c("name1", "name2", "name3")

#想通过列名重命名某一列
library(gcookbook) #为了使用数据集
names(anthoming) #输出列名

names(anthoming)[names(anthoming) == "ctrl"] <- c("Control")
names(anthoming)[names(anthoming) == "expt"] <- c("Experimental")

names(anthoming)[1] <- "Angle"
names(anthoming)
#=========================================================================================
#重排序数据框的列
#=========================================================================================
#通过列的数值位置重排序
dat <- dat[c(1,3,2)]
#通过列的名称重排序
dat <- dat[c("coll", "col3", "col2")]


#=========================================================================================
#从数据框提取子集
#=========================================================================================
#使用subset()函数，可以筛选出复合一系列条件的行和选出特定的列
library(gcookbook) #为了使用数据集
climate

subset(climate, Source == "Berkeley", select = c(Year, Anomaly10y))

#通过|（OR) 和 & （AND)操作符同时世家多种筛选条件
subset(climate, Source == "Berkeley" & Year >= 1900 & Year <= 2000,
       select = c(Year, Anomaly10y))

#可以在方括号里面加入索引来得到子数据框。
climate[climate$Source=="Berkeley" & climate$Year >= 1900 & climate$Year <= 2000, c("Year", "Anomaly10y")]

climate[climate$Source=="Berkeley" & climate$Year >= 1900 & climate$Year <= 2000, c("Year", "Anomaly10y"), drop=FALSE]
#=========================================================================================
#改变因子水平的顺序
#=========================================================================================
#因子的水平可以有函数factor()具体设定。

#默认的因子水平的顺序是按字母排的
sizes <- factor(c("small", "large", "large", "small", "medium"))
sizes
#改变因子水平的顺序
sizes <- factor(sizes, levels = c("small", "medium", "large"))
sizes

#R中有两种因子：顺序因子(order factor)和常规因子（regular factor)
#在两种类型中，因子水平都是按某种顺序排列的：
#区别在于，对于顺序因子，因子水平的顺序是有意义的。
#而对于常规因子，因子水平的顺序却没有什么意义，仅仅是反映了数据是如何存储的。

#如果要颠倒因子水平的顺序，可以使用函数rev(levels())
factor(sizes, levels = rev(levels(sizes)))




#=========================================================================================
#根据数据的值改变因子水平的顺序
#=========================================================================================
#使用reorder()。 该函数有三个参数： 因子，排序依据的数据和汇总数据的函数
#复制一份数据，因为我们要修改它
iss <- InsectSprays
iss$spray

iss$spray <- reorder(iss$spray, iss$count, FUN = mean)
iss$spray
#新的顺序是由iss$spray中魅族iss$count的平均值决定的
#=========================================================================================
#改变因子水平的名称
#=========================================================================================
#使用plyr包中的revalue()函数或mapvalues()函数
sizes <- factor(c("small", "large", "large", "small", "medium"))
sizes

levels(sizes)

#通过函数revalue()传递一组映射关系
library(plyr)
sizes1 <- revalue(sizes, c(small="S", medium="M", large="L"))
sizes1

#也可以使用引号--如果原因子水平名称中存在空格等特殊字符，这将很有用
revalue(sizes, c("small"="S", "medium"="M", "large"="L"))

#mapvalue()函数使用两组向量，而不是一组映射关系向量
mapvalues(sizes, c("small", "medium","large"), c("S", "M", "L"))

#通过水平原名称找到某个水平然后重命名
levels(sizes)[levels(sizes)=="large"] <- "L"
levels(sizes)[levels(sizes)=="medium"] <- "M"
levels(sizes)[levels(sizes)=="samll"] <- "S"
sizes

#如果要改变所有水平的名称，可以给levels()传递一个list类型的参数
sizes <- factor(c("small", "large", "large", "small", "medium"))
levels(sizes) <- list(S="small", M="medium", L="large")
sizes

#在这个方法中，所有的因子水平必须在一个list里面指定。
#如果这个list里面有任何的缺失，缺失的值最终会以NA代替




#=========================================================================================
#去掉因子中不再使用的水平
#=========================================================================================
sizes <- factor(c("small", "large", "large", "small", "medium"))
sizes <- sizes[1:3]
sizes

#为了删除这些不需要的水平，可以使用droplevels()函数
sizes <- droplevels(sizes)
sizes
#droplevels()函数保留了因子水平的顺序
#=========================================================================================
#在字符向量中改变元素的名称
#=========================================================================================
#用plyr包中的revalue()函数或者mapvalues()函数
sizes <- c("small", "large", "large", "small", "medium")
sizes

#通过函数revalue(),传递一组映射关系
sizes1 <- revalue(sizes, c(small="S", medium="M", large="L"))
sizes1

#也可以使用引号--如果原因子水平名称中存在空格等特殊字符，这将很有用
revalue(sizes, c("small"="S",  medium="M", large="L" ))
mapvalues(sizes, c("small", "medium","large"), c("S", "M", "L"))

#更常用的是
sizes <- c("small", "large", "large", "small", "medium")
sizes
sizes[sizes=="small"] <- "S"
sizes[sizes=="medium"] <- "M"
sizes[sizes=="large"] <- "L"
sizes


#=========================================================================================
#把一个分类变量转化成另一个分类变量
#=========================================================================================



#=========================================================================================
#连续变量转变为分类变量
#=========================================================================================
#使用cut()
pg <- PlantGrowth[c(1,2,11,21,22), ]
pg

pg$wtdlass <- cut(pg$weight, breaks = c(0,5,6,Inf))
pg

#为了改变因子水平的名称，我们可以使用cut()中的labels参数：
pg$wtdlass <- cut(pg$weight, breaks = c(0,5,6,Inf),
                  labels = c("small", "medium", "large"))
pg

#cut()生成的区间是左开右闭， 即不会包含最小值，但是包含了最大值。
#对于值最小的一类，可以通过设定参数include.lowest=TRUE,使得它同时包含最小值和最大值
#如果你想让生成的区间是左闭右开的，设定参数right=FALSE

#=========================================================================================
#变量转换
#=========================================================================================
#可以使用$操作符来引用新列并对其赋予新值
library(gcookbook) #为了使用数据集
#复制数据集
hw <- heightweight
hw
hw$heightCm <- hw$heightIn * 2.54
hw

#为了使代码更容易阅读，可以使用transform()或plyr包中的mutate()函数。
#仅需指定数据框一次，将其作为函数的第一参数；
#提供了非常清晰的语法，尤其适合转换多个变量
hw <- heightweight
hw <- transform(hw, heightCm = heightIn * 2.54, weightKg = weightLb/2.204)
hw

library(plyr)
hw <- heightweight
hw <- mutate(hw, heightCm = heightIn*2.54, weightKg=weightLb/2.204)
hw




#=========================================================================================
#按组转换数据
#=========================================================================================
library(MASS) #为了使用数据集
library(plyr)
cb <- ddply(cabbages, "Cult", transform, DevWt - mean(HeadWt))
cabbages

transform(cabbages, DevWt = HeadWt - mean(HeadWt))

#标准化前
ggplot(cb, aes(x=Cult, y=HeadWt)) + geom_boxplot()
#标准化后
ggplot(cb, aes(x=Cult, y=DevWt)) + geom_boxplot()



#=========================================================================================
#分组汇总数据
#=========================================================================================
#配合summarise()函数使用plyr包中的ddply()函数，并指定要进行的操作即可
library(MASS) #为了使用数据集
library(plyr)

ddply(cabbages, c("Cult", "Date"), summarise, Weight = mean(HeadWt),
      VitC = mean(VitC))

Cabbages


#=========================================================================================
#使用标准误差和置信区间来汇总数据
#=========================================================================================

#=========================================================================================
#把数据框从“宽”变“长”
#=========================================================================================

#=========================================================================================
#把数据框从“长”变“宽”
#=========================================================================================



#=========================================================================================
#把实践序列数据对象拆分成时间和数据
#=========================================================================================
